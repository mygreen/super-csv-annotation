<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Utils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Super CSV Annotation</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.supercsv.util</a> &gt; <span class="el_source">Utils.java</span></div><h1>Utils.java</h1><pre class="source lang-java linenums">package com.github.mygreen.supercsv.util;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import com.github.mygreen.supercsv.annotation.PatternFlag;
import com.github.mygreen.supercsv.builder.BuildCase;


/**
 * ユーティリティクラス。
 * 
 * @version 2.2
 * @author T.TSUCHIE
 *
 */
<span class="nc" id="L22">public class Utils {</span>
    
    /**
     * &lt;a href=&quot;http://www.joda.org/joda-time/&quot; target=&quot;_blank&quot;&gt;Joda-Time&lt;/a&gt;のライブラリが利用可能かどうか。
     */
    public static final boolean ENABLED_LIB_JODA_TIME;
    static {
        boolean enabled;
        try {
<span class="fc" id="L31">            Class.forName(&quot;org.joda.time.LocalDateTime&quot;);</span>
<span class="fc" id="L32">            enabled = true;</span>
<span class="nc" id="L33">        } catch(ClassNotFoundException e) {</span>
<span class="nc" id="L34">            enabled = false;</span>
<span class="fc" id="L35">        }</span>
<span class="fc" id="L36">        ENABLED_LIB_JODA_TIME = enabled;</span>
<span class="fc" id="L37">    }</span>
    
    /**
     * 文字列が空文字か判定する。
     * @param str
     * @return
     */
    public static boolean isEmpty(final String str) {
<span class="fc bfc" id="L45" title="All 4 branches covered.">        if(str == null || str.isEmpty()) {</span>
<span class="fc" id="L46">            return true;</span>
        }
        
<span class="fc bfc" id="L49" title="All 2 branches covered.">        if(str.length() == 1) {</span>
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">            return str.charAt(0) == '\u0000';</span>
        }
        
<span class="fc" id="L53">        return false;</span>
    }
    
    /**
     * 文字列が空文字でないか判定する。
     * @param str
     * @return
     */
    public static boolean isNotEmpty(final String str) {
<span class="fc bfc" id="L62" title="All 2 branches covered.">        return !isEmpty(str);</span>
    }
    
    /**
     * コレクションが空か判定する。
     * @param collection
     * @return nullまたはサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Collection&lt;?&gt; collection) {
<span class="nc bnc" id="L71" title="All 4 branches missed.">        if(collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L72">            return true;</span>
        }
        
<span class="nc" id="L75">        return false;</span>
    }
    
    public static boolean isNotEmpty(final Collection&lt;?&gt; collection) {
<span class="nc bnc" id="L79" title="All 2 branches missed.">        return !isEmpty(collection);</span>
    }
    
    /**
     * Mapが空か判定する。
     * @param map
     * @return nullまたはサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Map&lt;?, ?&gt; map) {
<span class="pc bpc" id="L88" title="2 of 4 branches missed.">        if(map == null || map.isEmpty()) {</span>
<span class="fc" id="L89">            return true;</span>
        }
        
<span class="nc" id="L92">        return false;</span>
    }
    
    public static boolean isNotEmpty(final Map&lt;?, ?&gt; map) {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        return !isEmpty(map);</span>
    }
    
    /**
     * 配列がが空か判定する。 
     * @param arrays
     * @return nullまたは、配列のサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Object[] arrays) {
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">        if(arrays == null || arrays.length == 0) {</span>
<span class="fc" id="L106">            return true;</span>
        }
        
<span class="fc" id="L109">        return false;</span>
    }
    
    /**
     * 配列が空でないか判定する
     * @param arrays
     * @return
     */
    public static boolean isNotEmpty(final Object[] arrays) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        return !isEmpty(arrays);</span>
    }
    
    /**
     * 文字列形式のロケールをオブジェクトに変換する。
     * &lt;p&gt;アンダーバーで区切った'ja_JP'を分解して、Localeに渡す。
     * @since 1.2
     * @param str
     * @return 引数が空の時はデフォルトロケールを返す。
     */
    public static Locale getLocale(final String str) {
        
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if(isEmpty(str)) {</span>
<span class="fc" id="L131">            return Locale.getDefault();</span>
        }
        
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if(!str.contains(&quot;_&quot;)) {</span>
<span class="nc" id="L135">            return new Locale(str);</span>
        }
        
<span class="fc" id="L138">        final String[] split = str.split(&quot;_&quot;);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if(split.length == 2) {</span>
<span class="fc" id="L140">            return new Locale(split[0], split[1]);</span>
            
        } else {
<span class="fc" id="L143">            return new Locale(split[0], split[1], split[2]);</span>
        }
        
    }
    
    /**
     * アノテーションの指定した属性値を取得する。
     * &lt;p&gt;アノテーションの修飾子はpublicである必要があります。&lt;/p&gt;
     * @param anno アノテーションのインスタンス
     * @param attrName 属性名
     * @param attrType 属性のタイプ。
     * @return 属性を持たない場合、空を返す。
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Optional&lt;T&gt; getAnnotationAttribute(final Annotation anno, final String attrName, final Class&lt;T&gt; attrType) {
        
        try {
<span class="fc" id="L160">            final Method method = anno.annotationType().getMethod(attrName);</span>
<span class="fc" id="L161">            method.setAccessible(true);</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            if(!attrType.equals(method.getReturnType())) {</span>
<span class="nc" id="L163">                return Optional.empty();</span>
            }
            
<span class="fc" id="L166">            final Object value = method.invoke(anno);</span>
<span class="fc" id="L167">            return Optional.of((T)value);</span>
            
<span class="fc" id="L169">        } catch (Exception e) {</span>
<span class="fc" id="L170">            return Optional.empty();</span>
        }
        
    }
    
    /**
     * アノテーションの指定した属性値を持つかどうか判定する。
     * &lt;p&gt;アノテーションの修飾子はpublicである必要があります。&lt;/p&gt;
     * @param anno アノテーションのインスタンス
     * @param attrName 属性名
     * @param attrType 属性のタイプ。
     * @return 属性を持つ場合trueを返す。
     */
    public static &lt;T&gt;  boolean hasAnnotationAttribute(final Annotation anno, final String attrName, final Class&lt;T&gt; attrType) {
        
<span class="fc" id="L185">        return getAnnotationAttribute(anno, attrName, attrType).isPresent();</span>
        
    }
    
    /**
     * アノテーションの属性「cases」を持つ場合、指定した種類を持つか判定する。
     * &lt;p&gt;属性「buildCase」を持たない場合、または、空の配列の場合は、必ずtrueを返します。&lt;/p&gt;
     * 
     * @param anno 判定対象のアノテーション。
     * @param buildCase 組み立てる種類。
     * @return trueの場合、指定した種類を含みます。
     * @throws NullPointerException anno or buildCase is null.
     */
    public static boolean containsBuildCase(final Annotation anno, final BuildCase buildCase) {
        
<span class="fc" id="L200">        Objects.requireNonNull(anno);</span>
<span class="fc" id="L201">        Objects.requireNonNull(buildCase);</span>
        
<span class="fc" id="L203">        final Optional&lt;BuildCase[]&gt; attrCases = getAnnotationAttribute(anno, &quot;cases&quot;, BuildCase[].class);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if(attrCases.isPresent()) {</span>
<span class="fc" id="L205">            final BuildCase[] casesValue = attrCases.get();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if(casesValue.length == 0) {</span>
                // 値が空の配列の場合
<span class="fc" id="L208">                return true;</span>
            }
            
<span class="fc bfc" id="L211" title="All 2 branches covered.">            for(BuildCase value : casesValue) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                if(value == buildCase) {</span>
<span class="fc" id="L213">                    return true;</span>
                }
            }
            
<span class="fc" id="L217">            return false;</span>
        }
        
        // 属性を持たない場合
<span class="fc" id="L221">        return true;</span>
    }
    
    /**
     * &lt;a href=&quot;http://www.joda.org/joda-time/&quot; target=&quot;_blank&quot;&gt;Joda-Time&lt;/a&gt;のライブラリが利用可能かどうか。
     * @return {@literal true}利用可能。
     */
    public static boolean isEnabledJodaTime() {
<span class="fc" id="L229">        return ENABLED_LIB_JODA_TIME;</span>
    }
    
    /**
     * プリミティブ型の初期値を取得する。
     * @param type プリミティブ型のクラス型。
     * @return 非プリミティブ型や該当するクラスがない場合はnullを返す。
     * @throws NullPointerException type is null.
     */
    public static Object getPrimitiveDefaultValue(final Class&lt;?&gt; type) {
        
<span class="fc" id="L240">        Objects.requireNonNull(type, &quot;type should not be null.&quot;);</span>
        
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if(!type.isPrimitive()) {</span>
<span class="fc" id="L243">            return null;</span>
            
<span class="fc bfc" id="L245" title="All 2 branches covered.">        } else if(boolean.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L246">            return false;</span>
            
<span class="fc bfc" id="L248" title="All 2 branches covered.">        } else if(char.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L249">            return '\u0000';</span>
            
<span class="fc bfc" id="L251" title="All 2 branches covered.">        } else if(byte.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L252">            return (byte)0;</span>
            
<span class="fc bfc" id="L254" title="All 2 branches covered.">        } else if(short.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L255">            return (short)0;</span>
            
<span class="fc bfc" id="L257" title="All 2 branches covered.">        } else if(int.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L258">            return 0;</span>
            
<span class="fc bfc" id="L260" title="All 2 branches covered.">        } else if(long.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L261">            return 0l;</span>
            
<span class="fc bfc" id="L263" title="All 2 branches covered.">        } else if(float.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L264">            return 0.0f;</span>
            
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        } else if(double.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L267">            return 0.0d;</span>
        }
        
<span class="nc" id="L270">        return null;</span>
        
    }
    
    /**
     * 文字列配列の結合
     * @param array1
     * @param array2
     * @return 結合した配列。引数のどちらからnullの場合は、cloneした配列を返します。
     */
    public static String[] concat(final String[] array1, final String[] array2) {
        
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">        if(array1 == null || array1.length == 0) {</span>
<span class="fc" id="L283">            return clone(array2);</span>
            
<span class="pc bpc" id="L285" title="1 of 4 branches missed.">        } else if(array2 == null || array2.length == 0) {</span>
<span class="fc" id="L286">            return clone(array1);</span>
        }
        
<span class="fc" id="L289">        final String[] joinedArray = new String[array1.length + array2.length];</span>
<span class="fc" id="L290">        System.arraycopy(array1, 0, joinedArray, 0, array1.length);</span>
<span class="fc" id="L291">        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);</span>
<span class="fc" id="L292">        return joinedArray;</span>
        
    }
    
    /**
     * 文字列の配列をクローンします。
     * @since 2.2
     * @param array クローン対象の配列
     * @return クローンした配列。引数がnullの場合は、nullを返します。
     */
    public static String[] clone(final String[] array) {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (array == null) {</span>
<span class="nc" id="L304">            return null;</span>
        }
<span class="fc" id="L306">        return array.clone();</span>
    }
    
    /**
     * コレクションを配列に変換する。
     * @param collection 変換対象のコレクション。
     * @return 変換した配列。
     * @throws NullPointerException collection is null.
     */
    public static int[] toArray(final Collection&lt;Integer&gt; collection) {
<span class="fc" id="L316">        Objects.requireNonNull(collection);</span>
        
<span class="fc" id="L318">        final int size = collection.size();</span>
<span class="fc" id="L319">        final int[] array = new int[size];</span>
        
<span class="fc" id="L321">        int i=0;</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        for(Integer value : collection) {</span>
<span class="fc" id="L323">            array[i] = value;</span>
<span class="fc" id="L324">            i++;</span>
<span class="fc" id="L325">        }</span>
        
<span class="fc" id="L327">        return array;</span>
    }
    
    /**
     * 正規表現のフラグを組み立てる。
     * @param flags 正規表現の列挙型のフラグ
     * @return
     */
    public static int buildRegexFlags(final PatternFlag[] flags) {
        
<span class="fc" id="L337">        int intFlag = 0;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for(PatternFlag flag : flags) {</span>
<span class="fc" id="L339">            intFlag = intFlag | flag.getValue();</span>
        }
        
<span class="fc" id="L342">        return intFlag;</span>
        
    }
    
    /**
     * 先頭の文字を小文字にする。
     * @param str
     * @return 引数がnull、空文字の場合、そのまま返す。
     */
    public static String uncapitalize(final String str) {
        final int strLen;
<span class="nc bnc" id="L353" title="All 4 branches missed.">        if(str == null || (strLen = str.length()) == 0) {</span>
<span class="nc" id="L354">            return str;</span>
        }
        
<span class="nc" id="L357">        return new StringBuilder(strLen)</span>
<span class="nc" id="L358">            .append(String.valueOf(str.charAt(0)).toLowerCase())</span>
<span class="nc" id="L359">            .append(str.substring(1))</span>
<span class="nc" id="L360">            .toString();</span>
    }
    
    /**
     * 文字列をトリムする。
     * @param value トリム対象の文字
     * @param trimmed トリムするかどうか。
     * @return トリミングした結果。
     */
    public static String trim(final String value, final boolean trimmed) {
<span class="pc bpc" id="L370" title="2 of 4 branches missed.">        if(!trimmed || value == null) {</span>
<span class="fc" id="L371">            return value;</span>
        }

<span class="nc" id="L374">        return value.trim();</span>

    }
    
    /**
     * 文字列をbooleanに変換します。
     * 
     * @param value 変換対象の値。
     * @param defaultValue 変換対象がnull or 空文字の時のデフォルト値。
     * @return 引数がnullのとき、falseを返します。
     */
    public static boolean toBoolean(final String value, final boolean defaultValue) {
<span class="fc" id="L386">        String text = trim(value, true);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if(isEmpty(text)) {</span>
<span class="fc" id="L388">            return defaultValue;</span>
        }
        
<span class="nc" id="L391">        return Boolean.valueOf(text.toLowerCase());</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>