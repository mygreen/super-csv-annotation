<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessageInterpolator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Super CSV Annotation</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.supercsv.localization</a> &gt; <span class="el_source">MessageInterpolator.java</span></div><h1>MessageInterpolator.java</h1><pre class="source lang-java linenums">package com.github.mygreen.supercsv.localization;

import java.util.Formatter;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.github.mygreen.supercsv.expression.ExpressionEvaluationException;
import com.github.mygreen.supercsv.expression.ExpressionLanguage;
import com.github.mygreen.supercsv.expression.ExpressionLanguageJEXLImpl;
import com.github.mygreen.supercsv.util.StackUtils;

/**
 * 名前付き変数のメッセージをフォーマットするクラス。
 * &lt;p&gt;&lt;code&gt;{...}&lt;/code&gt;の場合、変数を単純に置換する。
 * &lt;p&gt;&lt;code&gt;${...}&lt;/code&gt;の場合、EL式を利用し処理する。
 * &lt;p&gt;文字'$', '{', '}'は特殊文字のため、&lt;code&gt;\&lt;/code&gt;でエスケープを行う。
 * &lt;p&gt;ELのパーサは、{@link ExpressionLanguage}の実装クラスで切り替え可能。
 * &lt;p&gt;{@link MessageResolver}を指定した場合、メッセージ中の変数&lt;code&gt;{...}&lt;/code&gt;をメッセージ定義コードとして解決する。
 *    ただし、メッセージ変数で指定されている変数が優先される。
 * 
 * @version 2.4
 * @since 2.0
 * @author T.TSUCHIE
 *
 */
public class MessageInterpolator {
    
<span class="fc" id="L34">    private static final Logger logger = LoggerFactory.getLogger(MessageInterpolator.class);</span>
    
    private ExpressionLanguage expressionLanguage;
    
    /**
     * 再帰処理の最大回数
     */
<span class="pc" id="L41">    private int maxRecursiveDepth = 5;</span>
    
    /**
     * デフォルトのコンストラクタ
     * &lt;p&gt;式言語の処理実装として、JEXLの{@link ExpressionLanguageJEXLImpl} が設定されます。
     * 
     */
<span class="fc" id="L48">    public MessageInterpolator() {</span>
<span class="fc" id="L49">        this.expressionLanguage = new ExpressionLanguageJEXLImpl();</span>
<span class="fc" id="L50">    }</span>
    
    /**
     * 式言語の実装を指定するコンストラクタ
     * @param expressionLanguage EL式を評価する実装。
     */
<span class="nc" id="L56">    public MessageInterpolator(final ExpressionLanguage expressionLanguage) {</span>
<span class="nc" id="L57">        Objects.requireNonNull(expressionLanguage, &quot;expressionLanguage should not be null.&quot;);</span>
<span class="nc" id="L58">        this.expressionLanguage = expressionLanguage;</span>
<span class="nc" id="L59">    }</span>
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars) {
<span class="fc" id="L69">        return interpolate(message, vars, false);</span>
    }
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param recursive 変換したメッセージに対しても再帰的に処理するかどうか。
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars, boolean recursive) {
<span class="fc" id="L81">        return parse(message, vars, recursive, 0, null);</span>
    }
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * &lt;p&gt;{@link MessageResolver}を指定した場合、メッセージ中の変数をメッセージコードとして解決します。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param recursive 変換したメッセージに対しても再帰的に処理するかどうか。
     * @param messageResolver メッセージを解決するクラス。nullの場合、指定しないと同じ意味になります。
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars, boolean recursive,
            final MessageResolver messageResolver) {
<span class="fc" id="L96">        return parse(message, vars, recursive, 0, messageResolver);</span>
    }
    
    /**
     * メッセージをパースし、変数に値を差し込み、EL式を評価する。
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param recursive 変換したメッセージに対しても再帰的に処理するかどうか。
     * @param currentRecursiveDepth 現在の再帰処理回数。
     * @param messageResolver メッセージを解決するクラス。nullの場合、指定しないと同じ意味になります。
     * @return 補完したメッセージ。
     */
    protected String parse(final String message, final Map&lt;String, ?&gt; vars, final boolean recursive, final int currentRecursiveDepth,
            final MessageResolver messageResolver) {
        
        // 評価したメッセージを格納するバッファ。
<span class="fc" id="L112">        final StringBuilder sb = new StringBuilder(message.length());</span>
        
        /*
         * 変数とEL式を解析する際に使用する、スタック変数。
         * 式の開始が現れたらスタックに積み、式の終了が現れたらスタックから全てを取り出す。
         * スタックに積まれるのは、1つ文の変数またはEL式。
         */
<span class="fc" id="L119">        final LinkedList&lt;String&gt; stack = new LinkedList&lt;String&gt;();</span>
        
<span class="fc" id="L121">        final int length = message.length();</span>
        
<span class="fc bfc" id="L123" title="All 2 branches covered.">        for(int i=0; i &lt; length; i++) {</span>
<span class="fc" id="L124">            final char c = message.charAt(i);</span>
            
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if(StackUtils.equalsTopElement(stack, &quot;\\&quot;)) {</span>
                // 直前の文字がエスケープ文字の場合、エスケープ文字として結合する。
<span class="fc" id="L128">                String escapedChar = StackUtils.popup(stack) + c;</span>
                
<span class="fc bfc" id="L130" title="All 2 branches covered.">                if(!stack.isEmpty()) {</span>
                    // 取り出した後もスタックがある場合は、式の途中であるため、再度スタックに積む。
<span class="fc" id="L132">                    stack.push(escapedChar);</span>
                    
                } else {
                    // 取り出した後にスタックがない場合は、エスケープを解除して通常の文字として積む。
<span class="fc" id="L136">                    sb.append(c);</span>
                    
                }
                
<span class="fc bfc" id="L140" title="All 2 branches covered.">            } else if(c == '\\') {</span>
                // エスケープ文字の場合はスタックに積む。
<span class="fc" id="L142">                stack.push(String.valueOf(c));</span>
                
<span class="fc bfc" id="L144" title="All 2 branches covered.">            } else if(c == '$') {</span>
<span class="fc" id="L145">                stack.push(String.valueOf(c));</span>
                
<span class="fc bfc" id="L147" title="All 2 branches covered.">            } else if(c == '{') {</span>
                
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">                if(!stack.isEmpty() &amp;&amp; !StackUtils.equalsAnyBottomElement(stack, new String[]{&quot;$&quot;, &quot;{&quot;})) {</span>
                    // スタックの先頭が式の開始形式でない場合
<span class="nc" id="L151">                    throw new MessageParseException(message, &quot;expression not start with '{' or '$'&quot;);</span>
                    
                } else {
<span class="fc" id="L154">                    stack.push(String.valueOf(c));</span>
                }
                
                
<span class="fc bfc" id="L158" title="All 2 branches covered.">            } else if(c == '}') {</span>
                
<span class="fc bfc" id="L160" title="All 2 branches covered.">                if(StackUtils.equalsAnyBottomElement(stack, new String[]{&quot;{&quot;, &quot;$&quot;})) {</span>
                    // 式の終わりの場合は、式を取り出し評価する。
<span class="fc" id="L162">                    String expression = StackUtils.popupAndConcat(stack) + c;</span>
                    
                    // エスケープを解除する
<span class="fc" id="L165">                    expression = removeEscapeChar(expression, '\\');</span>
                    
<span class="fc" id="L167">                    String result = evaluate(expression, vars, recursive, currentRecursiveDepth, messageResolver);</span>
<span class="fc" id="L168">                    sb.append(result);</span>
                    
<span class="fc" id="L170">                } else {</span>
<span class="fc" id="L171">                    sb.append(c);</span>
                    
                }
                
            } else {
                
<span class="fc bfc" id="L177" title="All 2 branches covered.">                if(stack.isEmpty()) {</span>
<span class="fc" id="L178">                    sb.append(c);</span>
                    
                } else {
<span class="fc" id="L181">                    stack.push(String.valueOf(c));</span>
                }
                
            }
            
        }
        
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if(!stack.isEmpty()) {</span>
<span class="fc" id="L189">            String val = StackUtils.popupAndConcat(stack);</span>
<span class="fc" id="L190">            val = removeEscapeChar(val, '\\');</span>
<span class="fc" id="L191">            sb.append(val);</span>
        }
        
<span class="fc" id="L194">        return sb.toString();</span>
    }
    
    private String evaluate(final String expression, final Map&lt;String, ?&gt; values, final boolean recursive,
            final int currentRecursiveDepth, final MessageResolver messageResolver) {
        
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if(expression.startsWith(&quot;{&quot;)) {</span>
            // 変数の置換の場合
<span class="fc" id="L202">            final String varName = expression.substring(1, expression.length()-1);</span>
            
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if(values.containsKey(varName)) {</span>
                // 該当するキーが存在する場合（再帰評価は行わない）
<span class="fc" id="L206">                final Object value = values.get(varName);</span>
<span class="fc" id="L207">                final String eval = Objects.toString(value, &quot;&quot;);</span>
<span class="fc" id="L208">                return eval;</span>
                
<span class="fc bfc" id="L210" title="All 2 branches covered.">            } else if(messageResolver != null) {</span>
                // メッセージコードをとして解決をする。
<span class="fc" id="L212">                final Optional&lt;String&gt; eval = messageResolver.getMessage(varName);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">                if(!eval.isPresent()) {</span>
                    // 該当するキーが存在しない場合は、値をそのまま返す。
<span class="fc" id="L215">                    return String.format(&quot;{%s}&quot;, varName);</span>
                }
                
<span class="fc bfc" id="L218" title="All 2 branches covered.">                if(recursivable(recursive, maxRecursiveDepth, currentRecursiveDepth, eval.get())) {</span>
<span class="fc" id="L219">                    return parse(eval.get(), values, recursive, currentRecursiveDepth + 1, messageResolver);</span>
                } else {
<span class="fc" id="L221">                    return eval.get();</span>
                }
                
            } else {
                // 該当するキーが存在しない場合は、値をそのまま返す。
<span class="fc" id="L226">                return expression.toString();</span>
            }
            
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        } else if(expression.startsWith(&quot;${&quot;)) {</span>
            // EL式を評価する（再帰評価は行わない）
<span class="fc" id="L231">            final String expr = expression.substring(2, expression.length()-1);</span>
<span class="fc" id="L232">            final String eval = evaluateExpression(expr, values);</span>
<span class="fc" id="L233">            return eval;</span>
            
        }
        
<span class="nc" id="L237">        throw new MessageParseException(expression, &quot;not support expression.&quot;);</span>
        
    }
    
    /**
     * 現在の再帰回数が最大回数に達しているかどうか。
     * 
     * @param recursive 再帰的に処理するかどうか。
     * @param maxRecursion 最大再帰回数
     * @param currentDepth 再帰回数
     * @param expression 再帰対象の式
     * @return 最大再帰回数を超えていなければfalseを返す。
     */
    private boolean recursivable(final boolean recursive, final int maxRecursion, final int currentDepth, final String expression) {

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if(!recursive) {</span>
<span class="nc" id="L253">            return false;</span>
        }

<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if(maxRecursion &lt;= 0) {</span>
            // 再帰回数の制限なし。
<span class="nc" id="L258">            return true;</span>
        }

<span class="fc bfc" id="L261" title="All 2 branches covered.">        if(currentDepth &lt;= maxRecursion) {</span>
<span class="fc" id="L262">            return true;</span>
        }

<span class="fc" id="L265">        logger.warn(&quot;Over recursive depth : currentDepth={}, maxDepth={}, expression={}.&quot;, currentDepth, maxRecursion, expression);</span>

<span class="fc" id="L267">        return false;</span>

    }
    
    /**
     * EL式を評価する。
     * @param expression EL式
     * @param values EL式中の変数。
     * @return 評価した式。
     * @throws ExpressionEvaluationException 
     */
    protected String evaluateExpression(final String expression, final Map&lt;String, ?&gt; values) throws ExpressionEvaluationException {
        
<span class="fc" id="L280">        final Map&lt;String, Object&gt; context = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L281">        context.putAll(values);</span>
        
        // フォーマッターの追加
<span class="fc" id="L284">        context.computeIfAbsent(&quot;formatter&quot;, key -&gt; new Formatter());</span>
        
        /*
         * 以下のケースの時、評価値はnullが返されるため、空文字に変換する。
         * ・JEXLで存在しない変数名のとき。
         * ・ELインジェクション対象の式のとき
         */
<span class="fc" id="L291">        final String evalValue = Objects.toString(expressionLanguage.evaluate(expression, context), &quot;&quot;);</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if(logger.isTraceEnabled()) {</span>
<span class="nc" id="L293">            logger.trace(&quot;evaluate expression language: expression='{}' ===&gt; value='{}'&quot;, expression, evalValue);</span>
        }
        
<span class="fc" id="L296">        return evalValue;</span>
    }
    
    /**
     * エスケープ文字を除去した文字列を取得する。
     * @param str
     * @param escapeChar
     * @return
     */
    private String removeEscapeChar(final String str, final char escapeChar) {
        
<span class="pc bpc" id="L307" title="2 of 4 branches missed.">        if(str == null || str.isEmpty()) {</span>
<span class="nc" id="L308">            return str;</span>
        }
        
<span class="fc" id="L311">        final String escapeStr = String.valueOf(escapeChar);</span>
<span class="fc" id="L312">        StringBuilder sb = new StringBuilder();</span>
        
<span class="fc" id="L314">        final LinkedList&lt;String&gt; stack = new LinkedList&lt;&gt;();</span>
        
<span class="fc" id="L316">        final int length = str.length();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        for(int i=0; i &lt; length; i++) {</span>
<span class="fc" id="L318">            final char c = str.charAt(i);</span>
            
<span class="fc bfc" id="L320" title="All 2 branches covered.">            if(StackUtils.equalsTopElement(stack, escapeStr)) {</span>
                // スタックの一番上がエスケープ文字の場合
<span class="fc" id="L322">                StackUtils.popup(stack);</span>
<span class="fc" id="L323">                sb.append(c);</span>
                
<span class="fc bfc" id="L325" title="All 2 branches covered.">            } else if(c == escapeChar) {</span>
                // スタックに積む
<span class="fc" id="L327">                stack.push(String.valueOf(c));</span>
                
            } else {
<span class="fc" id="L330">                sb.append(c);</span>
            }
            
        }
        
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if(!stack.isEmpty()) {</span>
<span class="nc" id="L336">            sb.append(StackUtils.popupAndConcat(stack));</span>
        }
        
<span class="fc" id="L339">        return sb.toString();</span>
        
    }
    
    /**
     * EL式を解析する実装クラスを取得する。
     * @return
     */
    public ExpressionLanguage getExpressionLanguage() {
<span class="nc" id="L348">        return expressionLanguage;</span>
    }
    
    /**
     * EL式を解析する実装クラスを設定する。
     * @param expressionLanguage EL式の解析するクラスの実装。
     */
    public void setExpressionLanguage(ExpressionLanguage expressionLanguage) {
<span class="nc" id="L356">        this.expressionLanguage = expressionLanguage;</span>
<span class="nc" id="L357">    }</span>
    
    /**
     * 評価した変数やEL式を再帰的に処するときの最大回数を取得します。
     * 
     * @since 2.4
     * @return 再帰的に処するときの最大回数。
     */
    public int getMaxRecursiveDepth() {
<span class="nc" id="L366">        return maxRecursiveDepth;</span>
    }
    
    /**
     * 評価した変数やEL式を再帰的に処するときの最大回数を設定します。
     * 
     * @since 2.4
     * @param maxRecursiveDepth 再帰的に処するときの最大回数。{@literal -1} のとき制限はありません。
     */
    public void setMaxRecursiveDepth(int maxRecursiveDepth) {
<span class="fc" id="L376">        this.maxRecursiveDepth = maxRecursiveDepth;</span>
<span class="fc" id="L377">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>